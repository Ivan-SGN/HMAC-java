
# Contents
- [Overview](#overview)
- [Features](#features)
- [Architecture](#architecture)
- [API](#api)
    - [Общие правила](#общие-правила)
    - [POST /sign](#post-sign)
    - [POST /verify](#post-verify)
- [Quick Start](#quick-start)
    - [Запуск через Docker-образ](#запуск-через-docker-образ)
    - [Локальный запуск без Docker](#локальный-запуск-без-docker)
  
# Overview

HTTP-сервис для подписи и проверки целостности сообщений
Сервис решает задачу подтверждения того, что сообщение:
  * не было изменено после подписи;
  * было подписано стороной, обладающей общим секретным ключом.

Для подписи и проверки используется симметричный алгоритм HMAC (Hash-based Message Authentication Code).

---

# Features

Сервис предоставляет следующие возможности:
1. Подпись произвольных строковых сообщений с использованием алгоритма HMAC-SHA256.
2. Проверка соответствия подписи сообщению с использованием тайминг-стойкого сравнения, устойчивого к атакам по времени выполнения.
3. Строгая валидация входных данных:
   * чтение и ограничение размера тела запроса; 
   * валидация HTTP-метода и Content-Type; 
   * парсинг JSON; 
   * формирование унифицированных HTTP-ответов; 
   * централизованное логирование результатов обработки запросов.
4. Возврат детерминированных подписей: одинаковое сообщение при неизменном секрете всегда даёт одну и ту же подпись.
5. Загрузка и валидация конфигурации из JSON-файла с отказом запуска при некорректных параметрах.
6. Логирование ключевых событий жизненного цикла сервиса и HTTP-запросов без утечки чувствительных данных (секрета и содержимого сообщений).
7. Запуск сервиса как локально, так и в Docker-контейнере с возможностью передачи конфигурации извне.
---

# Architecture
Основные компоненты:

1. HTTP-слой (api) Содержит:
   * ServerHMAC — точка входа приложения, сборка всех зависимостей, запуск и остановка сервера. 
   * HTTP-хендлеры (SignatureHandler, VerifyHandler), каждый из которых отвечает строго за один эндпоинт. 
   * BaseHttpHandler — базовый класс с общей логикой:
2. Сервисный слой (service)
Представлен интерфейсом SignatureService и реализацией HmacSignatureService.
Отвечает исключительно за криптографическую логику:
вычисление HMAC-подписи;
проверку подписи;
тайминг-стойкое сравнение байтовых массивов.
3. Конфигурация (config)
   * ConfigLoader — загрузка и первичная валидация config.json, декодирование секрета. 
   * AppConfig — неизменяемая модель конфигурации с бизнес-валидацией параметров.
4. Утилиты (util)
Содержат вспомогательные классы, не зависящие от бизнес-логики:
Base64/Base64URL кодирование и декодирование;
настройка Gson.
5. Логирование 
   * Реализовано через SLF4J + Logback.
   * Логирование централизовано:
   * HTTP-ответы логируются на уровне базового хендлера;
   * Сервисная логика логируется минимально для отсутсвия дублирования и предназначена для дебага.
   * Конфигурация логирования - logback.xml
---

# API

Сервис предоставляет минимальный REST API для подписи сообщений и проверки их целостности с использованием HMAC-SHA256.

## Общие правила

- Формат тела запроса и ответа: `application/json`
- Кодировка: UTF-8
- Сообщение передаётся как строка
- Подпись кодируется в `base64url` **без паддинга** (URL-safe)

---

## POST /sign

Возвращает подпись для заданного сообщения.

### Request
#### curl
```bash
curl -X POST http://localhost:8080/sign \
  -H "Content-Type: application/json" \
  -d '{
    "msg": "hello"
  }'
````
#### Request body
```json
{
  "msg": "string"
}
```
---

### Response

Успешный ответ (200):

```json
{
  "signature": "base64url"
}
```

### Ошибки

- **400 Bad Request**
  - `invalid_json` — тело запроса не является валидным JSON
  - `invalid_msg` — поле `msg` отсутствует, пустое или не строка
- **413 Payload Too Large**
  - `payload_too_large` — размер тела запроса превышает `maxMsgSizeBytes`
- **415 Unsupported Media Type**
  - `unsupported_media_type` — `Content-Type` не `application/json`
- **405 Method Not Allowed**
  - `method_not_allowed` — используется HTTP-метод, отличный от POST
- **500 Internal Server Error**
  - `internal` — внутренняя ошибка сервера
---

## POST /verify

Проверяет, соответствует ли подпись сообщению.

### Request
### curl
```bash
curl -X POST http://localhost:8080/verify \
  -H "Content-Type: application/json" \
  -d '{
    "msg": "hello",
    "signature": "XyZabc123..."
  }'
```
#### Request body

```json
{
  "msg": "string",
  "signature": "base64url"
}
```

### Response

Подпись соответствует сообщению (200):

```json
{
  "ok": true
}
```

Подпись не соответствует сообщению (200):

```json
{
  "ok": false
}
```


### Errors

- **400 Bad Request**
  - `invalid_json` — тело запроса не является валидным JSON
  - `invalid_msg` — поле `msg` или `signature` отсутствует либо пустое
  - `invalid_signature_format` — подпись не является валидной `base64url`
- **413 Payload Too Large**
  - `payload_too_large` — размер тела запроса превышает `maxMsgSizeBytes`
- **415 Unsupported Media Type**
  - `unsupported_media_type` — `Content-Type` не `application/json`
- **405 Method Not Allowed**
  - `method_not_allowed` — используется HTTP-метод, отличный от POST
- **500 Internal Server Error**
  - `internal` — внутренняя ошибка сервера

---

## Quick Start
Для запуска приложения необходимо:
1. Склонировать репозиторий
2. Создать конфигурационный файл
3. Запустить сервис локально без Docker или в Docker

## Запуск через Docker-образ
### Клонирование репозитория

```bash
git clone <URL_РЕПОЗИТОРИЯ>
cd hmac-java
```

Сервис запускается в Docker-контейнере и использует внешний JSON-файл конфигурации.

### Конфигурация
В репозитории присутствует файл `config.example.json`.
Он содержит **пример конфигурации** и используется как шаблон. Необходимо скопировать его в `config.json` и добавить секрет.


Для запуска сервиса необходим файл `config.json` со следующей структурой:

```json
{
  "hmacAlg": "HmacSHA256",
  "secret": "BASE64_SECRET",
  "listenPort": 8080,
  "maxMsgSizeBytes": 1048576
}
```

Параметры конфигурации:

- `hmacAlg` — алгоритм HMAC (поддерживается `HmacSHA256`)
- `secret` — общий секретный ключ в формате Base64
- `listenPort` — порт, на котором будет запущен HTTP-сервер
- `maxMsgSizeBytes` — максимальный допустимый размер HTTP-сообщения в байтах

### Генерация секрета

Секрет — это общий ключ для HMAC. Его нужно один раз сгенерировать на стороне владельца сервиса, закодировать в Base64 и вставить в поле `secret` в `config.json`. Это делается внешней утилитой (OpenSSL / PowerShell)

1. Выполнить команду генерации (ниже).
2. Скопировать получившуюся строку целиком.
3. Вставить её в `config.json` в поле `secret`.

#### macOS / Linux (OpenSSL)

Требуется установленный `openssl` (обычно уже есть в системе).

```bash
openssl rand -base64 32
```

#### Windows (PowerShell)

```powershell
[Convert]::ToBase64String((1..32 | ForEach-Object { Get-Random -Maximum 256 }))
```

---

### Сборка Docker-образа

Docker-образ сервиса собирается из корня проекта:

```bash
docker build -t hmac-java .
```

---

### Запуск контейнера
Для запуска сервиса необходимо передать путь к файлу конфигурации внутрь контейнера по инструкции
```bash
docker run --rm \
  -p 8080:8080 \
  -v "$(pwd)/config.json:/app/config.json:ro" \
  hmac-java \
  /app/config.json
```

После запуска сервис будет доступен по адресу:

```
http://localhost:8080
```

## Локальный запуск без Docker

1. Убедиться, что установлен JDK 17+ (или тот, который используется в проекте).
2. Скопировать шаблон конфигурации и создать рабочий конфиг
3. Сгенерировать `secret` (см. блок «Генерация секрета» выше), вставить строку Base64 в поле `secret` файла `config.json`.
4. Скомпилировать проект (из корня репозитория):

```bash
javac -cp "lib/*" -d out $(find src -name "*.java")
```

5. Запустить сервер, передав путь до конфига:
```bash
java -cp "out:lib/*" ru.yandex.practicum.api.ServerHMAC config.json
```
Если аргумент не передавать, будет использован путь по умолчанию: `config.json`.


